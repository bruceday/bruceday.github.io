<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-data-flow-analysis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/31/data-flow-analysis/" class="article-date">
  <time class="dt-published" datetime="2023-10-31T06:30:04.000Z" itemprop="datePublished">2023-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/10/31/data-flow-analysis/">数据流分析</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数据流分析"><a href="#数据流分析" class="headerlink" title="数据流分析"></a>数据流分析</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/10/31/data-flow-analysis/" data-id="clotmc70o00053gtt6ffraiub" data-title="数据流分析" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-symbolic-execution" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/31/symbolic-execution/" class="article-date">
  <time class="dt-published" datetime="2023-10-31T06:29:09.000Z" itemprop="datePublished">2023-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/10/31/symbolic-execution/">符号执行</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="符号执行"><a href="#符号执行" class="headerlink" title="符号执行"></a>符号执行</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/10/31/symbolic-execution/" data-id="clotmc70w000f3gtt50tc7igj" data-title="符号执行" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-acm" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/31/acm/" class="article-date">
  <time class="dt-published" datetime="2023-10-31T06:23:18.000Z" itemprop="datePublished">2023-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/10/31/acm/">基础算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><p>五个基本的算法思想：分治法、贪心法、动态规划、回溯和分支限界。</p>
<h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><h2 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h2><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h2 id="分支限界"><a href="#分支限界" class="headerlink" title="分支限界"></a>分支限界</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/10/31/acm/" data-id="clotmc70k00013gttc5kaf4m9" data-title="基础算法" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-cpp-multi-thread" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/31/cpp-multi-thread/" class="article-date">
  <time class="dt-published" datetime="2023-10-31T05:48:37.000Z" itemprop="datePublished">2023-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/10/31/cpp-multi-thread/">C++多线程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h2><p>查看操作系统课程。</p>
<h2 id="C-11中新增加的多线程特性"><a href="#C-11中新增加的多线程特性" class="headerlink" title="C++11中新增加的多线程特性"></a>C++11中新增加的多线程特性</h2><ul>
<li><p>4种锁</p>
<ul>
<li>mutex互斥锁<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>lock()</td>
<td>上锁</td>
</tr>
<tr>
<td>unlock()</td>
<td>解锁</td>
</tr>
<tr>
<td>try_lock()</td>
<td>非阻塞获取锁</td>
</tr>
<tr>
<td>线程函数调用lock()的时候，有三种情况：</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>锁没有被取走，直接获取锁。</li>
<li>当前线程已经有该锁了，形成死锁。</li>
<li>锁被其他线程取走，进行阻塞等待。<br>函数调用try_lock的时候，有以下三种情况：</li>
<li>锁没有被取走，直接获取锁。</li>
<li>该线程已经有锁了，产生死锁。</li>
<li>锁被其他线程取走，会返回false，而不是被阻塞。</li>
</ul>
</li>
<li>recursive_mutex<br>允许递归上锁，来获得互斥对象的多层所有权，在释放互斥量的时候也需要采用等量的unlock来进行解锁。</li>
<li>time_mutex<br>比mutex多了两个成员函数。<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>try_lock_for()</td>
<td>接受一个时间范围，表示在一段时间范围之内，线程如果没有获得锁则被阻塞住，如果此期间其他线程释放了锁，则该线程可以获得锁，如果超时，返回false</td>
</tr>
<tr>
<td>try_lock_util()</td>
<td>接受一个时间点作为参数，在指定时间未到来之前，线程如果没有获得锁则被阻塞住，如果此期间其他线程释放了锁，则该线程可以获得锁，如果超时返回false</td>
</tr>
</tbody></table>
</li>
<li>recurive_timed_mutex<br>较少使用。</li>
</ul>
</li>
<li><p>lock_guard<br>lock_guard是C++11中定义的模板类。主要通过RAII的方式，对其管理的互斥量进行了封装，在需要加锁的地方，只需要用上述介绍的任意互斥体实例化一个lock_guard，调用构造函数成功上锁，出作用域前，lock_guard对象要被销毁，调用析构函数自动解锁，可以有效避免死锁的问题。缺陷：太单一，用户没有办法对锁进行控制，因此C++11又提供了unique_lock。</p>
</li>
<li><p>unique_lock<br>与lock_gard类似，unique_lock类模板也是采用RAII的方式对锁进行了封装，并且也是独占所有权的方式管理mutex对象的上锁和解锁操作，即其对象之间不能发生拷贝。在构造时，unique_lock对象需要传入一个Mutex对象作为它的参数，新创建的unique_lock对象负责传入的Mutex对象的上锁和解锁的操作。使用以上类型互斥量实例化unique_lock对象的时候，自动调用构造函数上锁，unique_lock对象销毁时自动调用析构函数解锁，可以方便的防止死锁问题。与lock_guard不同的是，unique_lock更加的灵活，提供了很多成员函数。</p>
</li>
</ul>
<h2 id="锁和同步机制"><a href="#锁和同步机制" class="headerlink" title="锁和同步机制"></a>锁和同步机制</h2><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h2 id="并行算法和数据结构"><a href="#并行算法和数据结构" class="headerlink" title="并行算法和数据结构"></a>并行算法和数据结构</h2><h2 id="OpenMP-MPI"><a href="#OpenMP-MPI" class="headerlink" title="OpenMP&#x2F;MPI"></a>OpenMP&#x2F;MPI</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/10/31/cpp-multi-thread/" data-id="clotmc70m00033gtt2c9w211e" data-title="C++多线程" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-cpp11-feature" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/31/cpp11-feature/" class="article-date">
  <time class="dt-published" datetime="2023-10-31T05:48:37.000Z" itemprop="datePublished">2023-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/10/31/cpp11-feature/">C++11新特性</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <!-- ![avatar](cpp11-feature/cpp11-feature.png) -->

<!-- graph LR
N0["C++11新特性"]
N1_1["并发支持"]
N1_2["泛型编程"]
N1_3["简化使用"]
N1_4["内存模型"]
N1_5["线程与锁"]
N1_6["期值"]
N1_7["lambda"]
N1_8["变参模板"]
N1_9["tuple"]
N1_10["别名"]
N1_11["auto和decltype"]
N1_12["范围for"]
N1_13["移动语义"]
N1_14["资源管理指针"]
N1_15["其他"]
N2_1["统一初始化"]
N2_2["nullptr"]
N2_3["constexpr"]
N0---N1_1
N0---N1_2
N0---N1_3
N0---N1_4
N0---N1_5
N0---N1_6
N0---N1_7
N0---N1_8
N0---N1_9
N0---N1_10
N0---N1_11
N0---N1_12
N0---N1_13
N0---N1_14
N0---N1_15
N1_15---N2_1
N1_15---N2_2
N1_15---N2_3
-->
<h2 id="STL容器"><a href="#STL容器" class="headerlink" title="STL容器"></a>STL容器</h2><h3 id="std-array"><a href="#std-array" class="headerlink" title="std::array"></a>std::array</h3><h4 id="std-array和std-vector谁快？"><a href="#std-array和std-vector谁快？" class="headerlink" title="std::array和std::vector谁快？"></a>std::array和std::vector谁快？</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test_stl_array</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size = <span class="number">1000000000UL</span>;</span><br><span class="line">    <span class="keyword">auto</span> *datas = new <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="type">size_t</span>, size&gt;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        (*datas)[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    delete datas;</span><br><span class="line">    datas = nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_stl_vector</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size = <span class="number">1000000000UL</span>;</span><br><span class="line">    <span class="keyword">auto</span> *datas = new <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">size_t</span>&gt;(size, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        (*datas)[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    delete datas;</span><br><span class="line">    datas = nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用std::vector比std::array慢了约1s，可以忽略不计。</p>
<h4 id="std-array相当于原生数组的封装，因此在函数内部分配内存在函数的栈区，申请过大会发生栈爆。而std-vector即使在函数内部也是分配在堆区。"><a href="#std-array相当于原生数组的封装，因此在函数内部分配内存在函数的栈区，申请过大会发生栈爆。而std-vector即使在函数内部也是分配在堆区。" class="headerlink" title="std::array相当于原生数组的封装，因此在函数内部分配内存在函数的栈区，申请过大会发生栈爆。而std::vector即使在函数内部也是分配在堆区。"></a>std::array相当于原生数组的封装，因此在函数内部分配内存在函数的栈区，申请过大会发生栈爆。而std::vector即使在函数内部也是分配在堆区。</h4><h4 id="std-array需要在申请内存指定长度，std-vector也可以事先申请定长长度。"><a href="#std-array需要在申请内存指定长度，std-vector也可以事先申请定长长度。" class="headerlink" title="std::array需要在申请内存指定长度，std::vector也可以事先申请定长长度。"></a>std::array需要在申请内存指定长度，std::vector也可以事先申请定长长度。</h4><h4 id="不可滥用std-vector的resize，有时会拖慢性能，应该根据实际情况测试。"><a href="#不可滥用std-vector的resize，有时会拖慢性能，应该根据实际情况测试。" class="headerlink" title="不可滥用std::vector的resize，有时会拖慢性能，应该根据实际情况测试。"></a>不可滥用std::vector的resize，有时会拖慢性能，应该根据实际情况测试。</h4><h3 id="std-forward-list"><a href="#std-forward-list" class="headerlink" title="std::forward_list"></a>std::forward_list</h3><p>单向链表，比std::list更省空间。如果只需要单向的链表的，则可以用std::forwad_list代替list。</p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="为什么要使用智能指针？"><a href="#为什么要使用智能指针？" class="headerlink" title="为什么要使用智能指针？"></a>为什么要使用智能指针？</h3><p>手动内存分配和释放容易造成内存泄漏，智能指针能在分配的指针离开作用域后自动释放。</p>
<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>shared_ptr实现共享式拥有概念。多个智能指针可以指向同一对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用引用计数机制来表明资源被几个指针共享，每一个shared_ptr的拷贝都指向相同的内存。</p>
<ul>
<li>缺点<br>shared_ptr有循环引用的问题，但有时候在正常的业务逻辑处理中不可避免。可通过和weak_ptr配合使用消除循环引用。</li>
</ul>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>独占指针，可将控制权转移。</p>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr不能单独使用，只能和shared_ptr配合使用。借助 weak_ptr 类型指针可以获取 shared_ptr 指针的一些状态信息，比如有多少指向相同的 shared_ptr 指针、通过expired()判断shared_ptr 指针指向的堆内存是否已经被释放等等，还可以解决shared_ptr 循环引用的问题。</p>
<h3 id="shared-ptr和unique-ptr的选择"><a href="#shared-ptr和unique-ptr的选择" class="headerlink" title="shared_ptr和unique_ptr的选择"></a>shared_ptr和unique_ptr的选择</h3><p>推荐使用unique_ptr。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/10/31/cpp11-feature/" data-id="clotmc70p00073gtt05yk9rev" data-title="C++11新特性" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-cdc" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/31/cdc/" class="article-date">
  <time class="dt-published" datetime="2023-10-31T02:08:37.000Z" itemprop="datePublished">2023-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/10/31/cdc/">跨时钟域验证</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="为什么需要多个时钟？"><a href="#为什么需要多个时钟？" class="headerlink" title="为什么需要多个时钟？"></a>为什么需要多个时钟？</h2><p>现代芯片为了满足PPA（Performance,Power,Area），追求最大的性能，更低的功耗和更小的面积。一个简单的办法就是提高时钟频率，但是有三分之一功耗是时钟消耗的。因此，设计者要在功耗和性能两者取得一个折中。解决的方法是让多个不同的时钟处理不同的任务，性能要求高的用快时钟处理，性能要求低的用慢时钟处理。</p>
<h2 id="时钟域"><a href="#时钟域" class="headerlink" title="时钟域"></a>时钟域</h2><p>时钟域包含时钟和其所控制寄存器以及组合逻辑。大的设计通常会有数十个时钟域。这些时钟域之间的互连关系就构成了跨时钟域（CDC,clock domain crossings）。如图1所示是一个简单的CDC。<br><img src="/2023/10/31/cdc/figure1.png" alt="avatar"></p>
<h2 id="多时钟域带来什么问题？"><a href="#多时钟域带来什么问题？" class="headerlink" title="多时钟域带来什么问题？"></a>多时钟域带来什么问题？</h2><h3 id="亚稳态（Metastability）"><a href="#亚稳态（Metastability）" class="headerlink" title="亚稳态（Metastability）"></a>亚稳态（Metastability）</h3><h4 id="亚稳态及其成因"><a href="#亚稳态及其成因" class="headerlink" title="亚稳态及其成因"></a>亚稳态及其成因</h4><p><img src="/2023/10/31/cdc/figure2.png" alt="avatar"></p>
<h4 id="亚稳态解决方法"><a href="#亚稳态解决方法" class="headerlink" title="亚稳态解决方法"></a>亚稳态解决方法</h4><p>多位同步器<br><img src="/2023/10/31/cdc/figure3.png" alt="avatar"></p>
<h3 id="毛刺（Glitch）"><a href="#毛刺（Glitch）" class="headerlink" title="毛刺（Glitch）"></a>毛刺（Glitch）</h3><h4 id="毛刺及其成因"><a href="#毛刺及其成因" class="headerlink" title="毛刺及其成因"></a>毛刺及其成因</h4><p>如下所示为CDC convergence（重聚合）现象<br><img src="/2023/10/31/cdc/figure4.png" alt="avatar"></p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>产生毛刺的两个信号不在同一个时钟周期到达。</p>
<h3 id="总线不一致（Bus-Incoherency）"><a href="#总线不一致（Bus-Incoherency）" class="headerlink" title="总线不一致（Bus Incoherency）"></a>总线不一致（Bus Incoherency）</h3><h4 id="成因"><a href="#成因" class="headerlink" title="成因"></a>成因</h4><p><img src="/2023/10/31/cdc/figure5.png" alt="avatar"></p>
<h4 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h4><h3 id="数据丢失（Data-Loss）"><a href="#数据丢失（Data-Loss）" class="headerlink" title="数据丢失（Data Loss）"></a>数据丢失（Data Loss）</h3><h4 id="成因-1"><a href="#成因-1" class="headerlink" title="成因"></a>成因</h4><h4 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h4><p>握手协议<br><img src="/2023/10/31/cdc/figure6.png" alt="avatar"></p>
<p>FIFO<br><img src="/2023/10/31/cdc/figure7.png" alt="avatar"></p>
<h2 id="CDC-verification-methodology"><a href="#CDC-verification-methodology" class="headerlink" title="CDC verification methodology"></a>CDC verification methodology</h2><p><img src="/2023/10/31/cdc/figure9.png" alt="avatar"></p>
<h2 id="时钟网络的识别"><a href="#时钟网络的识别" class="headerlink" title="时钟网络的识别"></a>时钟网络的识别</h2><p>为了验证时钟结构，需要确定时钟信号和时钟信号衍生的时钟信号。然而，由于存在控制循环和时序转换使得找到时钟网络的边界是不寻常的。Hwever, a clock network includes sequential transformations, and control loops, which makes its boundaries not trivial to ﬁnd. For instance, structurally, there is no way to diﬀerentiate a conﬁguration register from a register which is part of the shaping logic (the cloud in Figure 3.1). Thus, the derived clocks cannot be restricted to the clock pins of the registers, and the conﬁguration signals cannot be restricted to the primary inputs. <u>The identiﬁcation of the clock paths and the control paths need to rely on heuristics.</u></p>
<p><img src="/2023/10/31/cdc/figure8.png" alt="avatar"></p>
<h3 id="Clock-Propagation"><a href="#Clock-Propagation" class="headerlink" title="Clock Propagation"></a>Clock Propagation</h3><p>时钟传播问题比较难。</p>
<h3 id="Conﬁguration-Signals"><a href="#Conﬁguration-Signals" class="headerlink" title="Conﬁguration Signals"></a>Conﬁguration Signals</h3><p>Conﬁguration signals are identiﬁed as the inputs to the clock network which are not on the clock path. A ﬁrst approximation would be to consider them as:</p>
<h3 id><a href="#" class="headerlink" title></a></h3><h2 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h2><h3 id="Identiﬁcation-of-the-Clock-Network"><a href="#Identiﬁcation-of-the-Clock-Network" class="headerlink" title="Identiﬁcation of the Clock Network"></a>Identiﬁcation of the Clock Network</h3><p>技术难点为Clock Propagation、循环结构、衍生时钟和Conﬁguration Signals。</p>
<h3 id="Liveness-Property"><a href="#Liveness-Property" class="headerlink" title="Liveness Property"></a>Liveness Property</h3><h3 id="Parametric-Analysis"><a href="#Parametric-Analysis" class="headerlink" title="Parametric Analysis"></a>Parametric Analysis</h3><h3 id="同步结构的分析"><a href="#同步结构的分析" class="headerlink" title="同步结构的分析"></a>同步结构的分析</h3><p>模式识别算法</p>
<h2 id="功能验证"><a href="#功能验证" class="headerlink" title="功能验证"></a>功能验证</h2><p>CDC涉及的主要的安全性验证，安全性验证本质上为状态机的可达性问题。</p>
<h3 id="模型生成"><a href="#模型生成" class="headerlink" title="模型生成"></a>模型生成</h3><p>这是一个难点。</p>
<h4 id="硬件模型"><a href="#硬件模型" class="headerlink" title="硬件模型"></a>硬件模型</h4><p>为了建立硬件的模型，有两种方式，一种是结构模型，一种是功能模型。结构模型用vertex-labeled directed graph表示，功能模型用moore machine表示。</p>
<h5 id="握手协议的一个例子"><a href="#握手协议的一个例子" class="headerlink" title="握手协议的一个例子"></a>握手协议的一个例子</h5><p>如图所示为握手协议的波形、握手协议的网表、对应的协议状态转换图和结构图。<br><img src="/2023/10/31/cdc/figure10.png" alt="avatar"><br><img src="/2023/10/31/cdc/figure11.png" alt="avatar"><br><img src="/2023/10/31/cdc/figure12.png" alt="avatar"><br><img src="/2023/10/31/cdc/figure13.png" alt="avatar"></p>
<h4 id="Justiﬁcation"><a href="#Justiﬁcation" class="headerlink" title="Justiﬁcation"></a>Justiﬁcation</h4><p>参见论文关于CEX的处理。<br>Brayton, Alan Mishchenko Niklas Een Robert. “A Toolbox for Counter-Example Analysis and Optimization.”</p>
<h4 id="-1"><a href="#-1" class="headerlink" title></a></h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/10/31/cdc/" data-id="clotmc70o00063gtt49xy65jm" data-title="跨时钟域验证" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/11/05/cpp-basic/">C++基础知识</a>
          </li>
        
          <li>
            <a href="/2023/11/05/graph-isomorphism/">图同构算法</a>
          </li>
        
          <li>
            <a href="/2023/11/05/kmp/">kmp</a>
          </li>
        
          <li>
            <a href="/2023/11/04/A-Memory-Model-for-Static-Analysis-of-C/">A Memory Model for Static Analysis of C</a>
          </li>
        
          <li>
            <a href="/2023/11/02/leetcode/">leetcode题解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>